<html>
    <head>
        <title>CCF - Concurrency Control Framework for Scala</title>
        <link rel="stylesheet" type="text/css" href="ccf.css">
    </head>
    <body>
        <h1>CCF - Concurrency Control Framework for Scala</h1>

        <ul>
            <li><a href="#whatisccf">What is CCF?</a></li>
            <li><a href="#download">Download</a></li>
            <li><a href="#introductiontosynchronization">Introduction to synchonization in collaborative editing</a></li>
        </ul>

        <a id="whatisccf"></a>
        <h2>What is CCF?</h2>
        <p>
        CCF is a Scala library aiming to make developing of collaborative
        software easier. CCF uses operational transformation (OT) for achieving
        concurrency control in systems in which collaborative editing takes
        place. In addition to operational transformation, CCF offers higher
        level APIs for synchronization of tree-like documents between multiple
        clients over HTTP/1.1 protocol. CCF is distributed under the <a
          href="http://www.apache.org/licenses/LICENSE-2.0.html">Apache 2.0
          license</a>.
        </p>

        <a id="download"></a>
        <h2>Download</h2>
        <p>
        The latest version of CCF is 0.2.0 and it was released on the 3rd of
        September, 2010. You can download the <a
          href=http://github.com/akisaarinen/ccf/tarball/v0.2.0>sources</a> or
        clone the Git <a
          href="http://github.com/akisaarinen/ccf">repository</a> by running:
        <pre> $ git clone http://github.com/akisaarinen/ccf.git</pre>
        </p>

        <a id="introductiontosynchronization"></a>
        <h2>Introduction to synchronization in collaborative editing</h2>
        <p>
        Synchronization between multiple parties in a collaborative
        group-editing system is an interesting problem that can be described
        for example as "the activity of coordinating the potentially
        interfering actions of processes that operate in parallel" [2]. Popular
        approaches for solving this problem include various locking schemes,
        global serialization of actions by a single party (usually the server)
        and finally what's called operational transformations (OT).
        </p>
        <p>
        CCF is based on one of these OT algorithms, which allow users to make
        instant changes to a local copy of the data, and then provide
        mechanisms for eventually synchronizing all of these clients in such a
        way, that intentions of all users are preserved whenever it's possible.
        Conflict situations are usually merged automatically, even though user
        interaction could be implemented when necessary.
        </p>
        <h3>CCF and Jupiter</h3>
        <p>
        CCF is based on an algorithm called Jupiter. It was introduced by
        Nichols et. al in the context of the Jupiter collaboration system
        already in 1995 [1]. A variant of this same algorithm was used in the
        <a href="http://wave.google.com">Google Wave</a> collaboration
        platform. Even though various more advanced algorithms have been
        developed since the introduction of Jupiter, the relative simplicity of
        this algorithm still makes it a powerful tool even today.
        </p>

        <h3>Limitations in CCF</h3>
        <p>
        CCF is suitable for synchronizing tree-like documents between multiple
        clients using one central server. There are algorithms that work in a
        pure peer-to-peer setting, but CCF won't.
        </p>

        <h3>How it works?</h3>
        <p> 
        Let's use a simple example to take a look at how CCF works. Consider an
        application that allows users to edit non-formatted basic text
        collaboratively. Each user has a client running, which is then
        connected to a central server over the Internet. The data structure of
        this application can be represented as a flat list or characters, which
        can also be considered as an ordered tree which has a fixed depth of 1.
        Each action the user makes, is represented as an operation. For this
        simple example, we have only two operations are available: insertion
        and deletion. 
        </p>
        <p>
        When a user writes a new character somewhere in the text, this will be
        encoded as an insert operation. This insert contains the character that
        is inserted, and the position where the user wanted to insert it, e.g.
        <i>insert(4, 'a')</i>. Insert is applied to the local copy of the
        user's document right away. Now, this operation along with information
        of what was the document state when this operation was created (the
        state is important, as we'll see), will be sent to the server. Upon
        receiving this message, the server will decode it back to an operation
        and state information. If nothing has happened concurrently, the server
        will then apply this operation to its local copy of the document, and
        then echo this same message to all other clients. Upon receiving,
        clients also apply the operation and at this time, all clients are in a
        synchronized state.
        </p>
        <p>
        Now, let's consider a case where two users make a modification
        simultaneously. First part is still similar, both operations get
        encoded as an operation and will be applied to the local copies of the
        users, after which operations along with their state information is
        sent to the server. Now the magic starts to happen. One of these
        messages will reach the server first, which means that it gets
        processed exactly the same way as in our first example, because from
        the server's point of view, nothing has happened concurrently (second
        request has not yet reached the server). However, when the second
        user's modification messagei reaches the server, it will notice that
        the state at the time of creation of that operation is different from
        server's current state. That's because of the first operation applied
        by the first user. 
        </p>
        <p>
        Now the server needs to <i>transform</i> the incoming operation in such
        a way, that the <i>intentions of the user are preserved</i>. Let's say
        the first operation was: <i>insert(4, 'a')</i> and the second operation
        was <i>delete(8)</i>. After the insert has been applied, the given
        index in the delete operation (8), is no longer valid. The insert to
        position 4 has transformed all text behind it by one. Delete will be
        transformed to <i>delete(9)</i> with help of a transformation function
        and the state information. This transformed operation will now be
        echoed to other clients.
        </p>
        <p>
        Our second example considered a case where operations had happened in
        the server before another operation reached the server. In this case,
        the server needs to <i>transform</i> the incoming operation to preserve
        its original intentions. This same thing can also happen in the client
        side. Let's extend our previous example that the user whose operation
        reached the server first, also inserted another character with
        <i>insert(1, 'b')</i>, but that this operation didn't reach the server
        before another client's delete. Now before echoed to this user, the
        delete was transformed to <i>delete(9)</i> in the server. However, when
        reaching the client, an <i>insert(1, 'b')</i> has been applied to the
        client's local copy of the document. Incoming operation needs once
        again to be transformed. We can detect this need from the state
        information, and incoming delete will then be shifted once more to
        <i>delete(10)</i>.
        </p>
        <p>
        This simple scheme of transforming all incoming operations both in the
        client and the server allows us to always apply any operation locally
        right away, and upon receiving other clients' modifications, just
        transform then appropriately.
        </p>
        <h3>References</h3>
        <p>
        [1] Nichols, D. A., Curtis, P., Dixon, M., and Lamping, J. High-
        latency, low-bandwidth windowing in the jupiter collaboration system.
        In UIST '95: Proceedings of the 8th annual ACM symposium on User
        interface and software technology (New York, NY, USA, 1995), ACM.
        </p>
        <p>
        [2] Greenberg, S., and Marwood, D. Real time groupware as a dis-
        tributed system: concurrency control and its effect on the interface. In
        CSCW '94: Proceedings of the 1994 ACM conference on Computer supported
        cooperative work (New York, NY, USA, 1994), ACM.
        </p>
        <p class="copyright">
        Copyright &copy; 2010.
        </p>
    </body>
</html>
